<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Desugaring async functions in Rust - ambiso&#x27;s blog</title>

      
        
          <link rel="alternate" type="application/atom+xml" title="RSS" href="https://ambiso.github.io/atom.xml">
        
          <link rel="alternate" type="application/rss+xml" title="RSS" href="https://ambiso.github.io/rss.xml">
        
      


      
          <link rel="stylesheet" href="https://ambiso.github.io/site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
          
      

      
      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js" defer></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous" defer>

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      
      
    </head>

    <body class="hack dark main container">
        
    
        
                
                    <header>
                        <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;ambiso.github.io">
                                <span itemprop="name">Home
                                </span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;ambiso.github.io&#x2F;categories">
                                <span itemprop="name">Categories
                                </span></a>
                        
                        </nav>
                    </header>
                
            
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Desugaring async functions in Rust</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>4 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2021-08-24
</span>
    </header>
    <div itemprop="articleBody">
      <p><a href="https://github.com/ambiso/future_without_async">Here</a> I implemented two simple futures without using <code>async fn</code>.</p>
<h2 id="a-simple-async-function">A simple async function</h2>
<p>We first look at the simplest possible example:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">does_nothing</span><span>() {}
</span></code></pre>
<p>An <code>async</code> function boils down to a function returning some type that implements the <a href="https://doc.rust-lang.org/std/future/trait.Future.html#"><code>Future</code></a> trait:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">does_nothing_desugared</span><span>() -&gt; impl Future&lt;Output=()&gt; {
</span><span>    </span><span style="color:#65737e;">/* ... */
</span><span>}
</span></code></pre>
<p>The <code>Future</code> trait looks like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub trait </span><span>Future {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Output;
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">poll</span><span>(</span><span style="color:#bf616a;">self</span><span>: Pin&lt;&amp;</span><span style="color:#b48ead;">mut Self</span><span>&gt;, </span><span style="color:#bf616a;">cx</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>Context&lt;&#39;_&gt;) -&gt; Poll&lt;</span><span style="color:#b48ead;">Self::</span><span>Output&gt;;
</span><span>}
</span></code></pre>
<p>It offers a poll function that an async runtime can call to make progress on the future.
We can implement this poll function by creating a struct that implements <code>Future</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>DoesNothingFuture;
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Future </span><span style="color:#b48ead;">for </span><span>DoesNothingFuture {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Output = ();
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">poll</span><span>(</span><span style="color:#bf616a;">self</span><span>: Pin&lt;&amp;</span><span style="color:#b48ead;">mut Self</span><span>&gt;, </span><span style="color:#bf616a;">_cx</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>Context&lt;&#39;_&gt;) -&gt; Poll&lt;</span><span style="color:#b48ead;">Self::</span><span>Output&gt; {
</span><span>        Poll::Ready(())
</span><span>    }
</span><span>}
</span></code></pre>
<p>Here the <code>poll</code> function immediately resolves the future to the empty tuple.
The alternative would be to return <code>Poll::Pending</code> to signal that it should be
polled again later. To determine when it should be polled again
Rust futures have a <a href="https://rust-lang.github.io/async-book/02_execution/03_wakeups.html">wakeup mechanism</a>, which I won't detail here.</p>
<p>The <code>does_nothing_desugared</code> function then just has to return a new instance
of the DoesNothingFuture:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">does_nothing_desugared</span><span>() -&gt; impl Future&lt;Output=()&gt; {
</span><span>    DoesNothingFuture {}
</span><span>}
</span></code></pre>
<h2 id="a-more-complex-example">A more complex example</h2>
<p>Now lets try desugaring a more complex async function.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_file</span><span>(</span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> File) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> v = Vec::new();
</span><span>    file.</span><span style="color:#96b5b4;">read_to_end</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> v).await.</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    String::from_utf8(v).</span><span style="color:#96b5b4;">unwrap</span><span>()
</span><span>}
</span></code></pre>
<p>The <code>read_file</code> function is more complex in that it has an argument and awaits another future.
To translate this function we again need a struct that implements <code>Future</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>ReadFileFuture&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a mut</span><span> File,
</span><span>    </span><span style="color:#bf616a;">v</span><span>: Option&lt;Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, </span><span style="color:#65737e;">// buffer to store data to
</span><span>    </span><span style="color:#bf616a;">state</span><span>: ReadFileState&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt;,
</span><span>    </span><span style="color:#bf616a;">_pin</span><span>: PhantomPinned, </span><span style="color:#65737e;">// Future is !Unpin
</span><span>}
</span><span>
</span><span style="color:#b48ead;">enum </span><span>ReadFileState&lt;&#39;a&gt; {
</span><span>    State0, </span><span style="color:#65737e;">// Initial
</span><span>    State1(Pin&lt;Box&lt;dyn Future&lt;Output=tokio::io::Result&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt;+</span><span style="color:#b48ead;">&#39;a</span><span>&gt;&gt;), </span><span style="color:#65737e;">// Await ReadToEnd future
</span><span>}
</span></code></pre>
<p>Here we take the reference to the file, a buffer to store the file contents to
and a state that contains nothing initially, but is then filled by
the <code>ReadToEnd</code> future when the <code>ReadFileFuture</code> is first polled.
We explicitly mark the future as <code>!Unpin</code> to avoid it being moved.
This is necessary since the <code>ReadToEnd</code> future holds references to <code>v</code> and to <code>file</code>.
Internally we need to use <code>unsafe</code> to circumvent the restrictions of <code>!Unpin</code>.
Here we must be careful not to move any members that another may hold references to.</p>
<p>The <code>poll</code> implementation checks which state we are in.
This roughly corresponds to the different entrypoints of the function:</p>
<ul>
<li>the main entrypoint of the function</li>
<li>points where <code>.await</code> is used in the function</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; Future </span><span style="color:#b48ead;">for </span><span>ReadFileFuture&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Output = String;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">poll</span><span>&lt;</span><span style="color:#b48ead;">&#39;b</span><span>&gt;(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>: Pin&lt;&amp;</span><span style="color:#b48ead;">&#39;b mut Self</span><span>&gt;, </span><span style="color:#bf616a;">cx</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>Context&lt;&#39;_&gt;) -&gt; Poll&lt;</span><span style="color:#b48ead;">Self::</span><span>Output&gt; {
</span><span>        </span><span style="color:#b48ead;">let</span><span> s = </span><span style="color:#b48ead;">unsafe </span><span>{ </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">as_mut</span><span>().</span><span style="color:#96b5b4;">get_unchecked_mut</span><span>() };
</span><span>        </span><span style="color:#b48ead;">loop </span><span>{
</span><span>            </span><span style="color:#b48ead;">match</span><span> s.state {
</span><span>                </span><span style="color:#65737e;">// Main entrypoint
</span><span>                ReadFileState::State0 =&gt; {
</span><span>                    </span><span style="color:#b48ead;">let</span><span> fut = s.file.</span><span style="color:#96b5b4;">read_to_end</span><span>(s.v.</span><span style="color:#96b5b4;">as_mut</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>());
</span><span>                    </span><span style="color:#b48ead;">let</span><span> wrapped = Box::pin(fut);
</span><span>                    </span><span style="color:#b48ead;">let</span><span> new_state = </span><span style="color:#b48ead;">unsafe </span><span>{ std::mem::transmute::&lt;_, ReadFileState&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt;&gt;(ReadFileState::State1(wrapped)) };
</span><span>                    s.state = new_state;
</span><span>                },
</span><span>                </span><span style="color:#65737e;">// Await ReadToEnd
</span><span>                ReadFileState::State1(</span><span style="color:#b48ead;">ref mut</span><span> fut) =&gt; {
</span><span>                    </span><span style="color:#b48ead;">let</span><span> r = fut.</span><span style="color:#96b5b4;">as_mut</span><span>().</span><span style="color:#96b5b4;">poll</span><span>(cx);
</span><span>                    </span><span style="color:#b48ead;">if</span><span> r.</span><span style="color:#96b5b4;">is_pending</span><span>() {
</span><span>                        </span><span style="color:#b48ead;">return </span><span>Poll::Pending;
</span><span>                    }
</span><span>                    </span><span style="color:#b48ead;">let</span><span> v = s.v.</span><span style="color:#96b5b4;">take</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                    </span><span style="color:#b48ead;">return </span><span>Poll::Ready(String::from_utf8(v).</span><span style="color:#96b5b4;">unwrap</span><span>());
</span><span>                },
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>We can then again simply return an instance of the struct in the desugared function:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_file_desugared</span><span>(</span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> File) -&gt; impl Future&lt;Output=String&gt; + &#39;_ {
</span><span>    ReadFileFuture {
</span><span>        file,
</span><span>        v: Some(Vec::new()),
</span><span>        state: ReadFileState::State0,
</span><span>        _pin: PhantomPinned {},
</span><span>    }
</span><span>}
</span></code></pre>
<p>I am not 100% sure my use of <code>unsafe</code> is sound here, in fact I would be surprised by it.
However, the application does run and seems to produce the correct result.</p>
<p>The transmute is used to convince the compiler to accept a different lifetime for <code>ReadFileState</code>.
This would likely not be necessary if Rust had support for self-referencing structs.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=9_3krAQtD2k">Jon Gjengset: The What and How of Futures and async/await in Rust</a></li>
<li><a href="https://www.youtube.com/watch?v=DkMwYxfSYNQ">Jon Gjengset: The Why, What, and How of Pinning in Rust</a></li>
<li><a href="https://users.rust-lang.org/t/desugaring-async-fn/63698/2">Yandros</a></li>
</ul>

    </div>

    
        <footer>
            <hr>
            <p>
                
                
                    
                    in <a href="https://ambiso.github.io/categories/rust/">rust</a>
                
                
            </p>
            
            
        </footer>
    
</article>


    </body>

</html>
